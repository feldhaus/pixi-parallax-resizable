<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>PIXI - Parallax - Resizable</title>
    <style>
        * {padding: 0; margin: 0}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.2/pixi.min.js"></script>
</head>
<body>
    <script type="text/javascript">
        // create application
        var app = new PIXI.Application();
        document.body.appendChild(app.view);
        
        // tilingSprite are the backgrounds
        var tilingSprites = [];
        
        // hero running animation
        var hero;
        
        // load assets
        PIXI.loader
            .add('assets/images/layer_01.png')
            .add('assets/images/layer_02.png')
            .add('assets/images/layer_03.png')
            .add('assets/images/layer_04.png')
            .add('assets/images/hero.png')
            .add('assets/images/hero.json')
            .load(onLoaded);
        
        function onLoaded(loader, resources) {
            // create a tiling sprites and add to stage
            for (var i = 0; i < 4; i++) {
                tilingSprites.push(new PIXI.extras.TilingSprite.fromImage(
                    'assets/images/layer_0' + (i+1) + '.png',
                    app.renderer.width,
                    app.renderer.height
                ));
                app.stage.addChild(tilingSprites[i]);
            }
            
            // get animation frames, create the hero and add it stage
            var frames = [];
            for (var i = 0; i < 10; i++) {
                frames.push(PIXI.Texture.fromFrame('0' + i + '.png'));
            }
            hero = new PIXI.extras.AnimatedSprite(frames);            
            hero.x = app.renderer.width / 2;
            hero.y = app.renderer.height / 2;
            hero.anchor.set(0.5, 1);
            hero.animationSpeed = 0.1;
            hero.play();
            app.stage.addChildAt(hero, app.stage.children.length-1);
            
            // ticker for doing render updates
            app.ticker.add(update);
            
            // adds event listeners
            resize();
            window.addEventListener('resize', resize);
            window.onorientationchange = resize;
        }
        
        function resize() {
            // get window size
            var width = window.innerWidth// || document.body.clientWidth;
            var height = window.innerHeight// || document.body.clientHeight;
                        
            // resize pixi renderer
            app.renderer.resize(width, height);
            
            for (var i = 0; i < tilingSprites.length; i++) {
                var tilingSprite = tilingSprites[i];
                
                // change tiling sprites sizes
                tilingSprite.width = width;
                tilingSprite.height = height;

                // and scale it based on window height
                var scale = height / tilingSprite.texture.height;
                tilingSprite.tileScale.set(scale, scale);
            }
            
            // keep the hero in the bottom-center position
            hero.x = width / 2;
            hero.y = height;
            
            // and scale the hero (max-height = height * 70%)
            var scale = (height * 0.7) / (hero.texture.height);
            hero.scale.set(scale, scale);
        }
        
        function update(deltaTime) {
            // changes 'x' tile position (parallax scrolling effect)
            for (var i = 0; i < tilingSprites.length; i++) {
                
                var scale = tilingSprites[i].tileScale.x;
                var speed = deltaTime * scale;
                tilingSprites[i].tilePosition.x -= (i + 1) * speed;
                
                // it's "fix" a tilisprite position bug
                var width = tilingSprites[i].texture.width * scale; 
                if (tilingSprites[i].tilePosition.x >= width) {
                    tilingSprites[i].tilePosition.x -= width;
                } else if (tilingSprites[i].tilePosition.x <= -width) {
                    tilingSprites[i].tilePosition.x += width;
                }
            }
        }
    </script>
</body>
</html>